<p align="center"><img width="794" height="307" alt="Image" src="https://github.com/user-attachments/assets/27018eed-4c3b-4814-b588-c5e77715c6bd" /><br><br>

### 사용 기술
---
BE : SpringBoot, Spring Webflux, Java

FE : React.js, JavaScript

DB/Cache : MySQL, Redis

INFRA : Kafka

ETC : SSE <br><br>

### 요청 흐름

---

1. 대기열 등록 요청 ( 이때, SSE 방식으로 서버와 클라이언트가 연결됩니다. )<br><br>

2. Redis ZSET 자료구조 대기열에 사용자 ID를 key, 요청 시각을 score로 설정하여 저장하고 outbox 테이블에 해당 사용자를 저장합니다. ( 상태 값 : “WAIT” )
   ( ZSET은 사용자 요청 시각을 score로 저장하기 때문에, 삽입되는 즉시 요청 시각 기준으로 자동 정렬되어 대기열 순서를 나타낼 수 있습니다. )<br><br>

3. 새로운 사용자 등록, 취소, 허용열 이동 등으로 대기열 변동이 발생하면 redis에 이를 반영하고 Outbox 테이블이 갱신됩니다.<br><br>

4. Outbox 테이블이 변경되어 Binary Log가 갱신되면 Debezium 커넥터가 이를 감지해, 해당 대기열의 이름인 queueType 값을 카프카로 발행합니다. 이후 컨슈머는 이 이벤트를 처리하며, 해당 queueType 대기열에 속한 사용자들의 최신 순위와 상태 정보를 Redis에서 조회한 뒤 SSE 방식으로 클라이언트에 전달합니다.<br><br>
   ( Redis 대기열에 있는 사용자의 경우 현재 순위를 전달하고, 허용열에 있는 사용자의 경우 ‘confirm’ 이벤트를 전달합니다 )

5. 사용자는 실시간으로 갱신되는 자신의 순위를 확인할 수 있으며, confirm 이벤트를 수신하면 예약 페이지로 이동하게 됩니다.<br><br>

### 구조 개선
---

만약 이벤트가 소실되어 특정 사용자가 타겟 페이지로 이동하지 못하는 상황이 발생한다면, 이는 서비스에 직접적인 영향을 줄 수 있습니다. 기존에는 Redis를 활용해 이벤트를 전송, 처리했지만, 이 방식에서는 이벤트 소실 시 재시도가 불가능한 구조라고 생각했습니다.

이러한 문제 해결을 위해 Kafka 기반의 이벤트 전송 구조로 개선하였으며, 이를 통해 이벤트 전송의 안정성을 확보하고, 전송 실패 시 재시도가 가능하도록 하였습니다.

또한, 서비스 내에서 특정 이벤트가 소실될 경우, 데이터베이스에는 변경 사항이 반영되었지만 이벤트 스트림에는 전달되지 않아 정합성이 깨질 위험이 있었습니다. 

이를 해결하기 위해 Debezium MySQL 커넥터를 활용하여 데이터베이스 테이블의 변경 사항을 감지하고 이를 Kafka 토픽으로 발행하도록 구현했습니다. 

이 방식은 데이터베이스 트랜잭션과 이벤트 발행을 연관하여 정합성 문제를 해결하도록 하였습니다.

또한, Debezium은 MySQL의 binlog를 기반으로 이벤트를 전달하기 때문에 이벤트 손실 없이 재시도가 가능하고, 변경 사항의 순서를 자연스럽게 보장할 수 있습니다.

결과적으로, Debezium 기반의 Transactional Outbox Pattern을 구현함으로써 DB와 이벤트 스트림 간의 불일치 문제를 해결하고, 이벤트 소실 방지, 순서 보장, 데이터 정합성을 처리할 수 있었습니다.<br><br>

### 추후 개선점
---
비동기 로직에서의 DB 사용은 트랜잭션 지연 및 연결 풀 고갈 등으로 병목을 유발할 수 있으므로 이를 제거하고 Kotlin 기반의 코루틴을 사용하여 경량 동시성 및 효율적인 비동기 처리를 하고자 하며, 이후 사용할 멱등성 로직 적용에서의 DB는 R2DBC를 사용하거나 블로킹 호출을 별도의 IO 디스패처로 분리하여 처리할 예정입니다  

추가적으로, 단일 서버에서 분산 서버로 확장 함으로써 부하 분산 및 고가용성을 확보할 계획입니다.
